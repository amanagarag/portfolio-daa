<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Learning Reflections & SDG Mapping</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f9f9f9;
            color: #333;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
        }

        header {
            background-color: #4CAF50;
            color: white;
            padding: 20px 0;
            text-align: center;
        }

        header h1 {
            margin: 0;
            font-size: 2.5rem;
        }

        section {
            background: white;
            padding: 20px;
            margin: 20px auto;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            max-width: 900px;
        }

        h2 {
            color: #4CAF50;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 5px;
            margin-bottom: 15px;
            font-size: 1.8rem;
        }

        h3 {
            color: #333;
            margin-top: 20px;
            font-size: 1.5rem;
        }

        ul {
            list-style: disc;
            padding-left: 20px;
        }

        li {
            margin-bottom: 10px;
        }

        p {
            margin-bottom: 15px;
        }

        footer {
            text-align: center;
            padding: 10px 0;
            background-color: #333;
            color: white;
        }

        .button-container {
            text-align: center;
            margin-top: 20px;
        }

        .button-container button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s, transform 0.2s;
        }

        .button-container button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        .button-container button:active {
            transform: translateY(2px);
        }
    </style>
</head>

<body>
    <header>
        <h1>Course Learning Reflections & SDG Mapping</h1>
    </header>

    <section>
        <h2>Course Learning Reflections</h2>

        <h3>1. What are the kinds of problems we see in nature?</h3>
        <ul>
            <li><strong>Iteration:</strong> Repeating instructions until a condition is met, such as looping through an array.</li>
            <li><strong>Recursion:</strong> Breaking problems into smaller subproblems, like calculating factorials or solving the Tower of Hanoi.</li>
            <li><strong>Backtracking:</strong> Incrementally exploring solutions and abandoning invalid paths, used in N-Queens or maze problems.</li>
        </ul>
        </section>
        
        <section>
        <h3>2. What is space and time efficiency? Why are they important?</h3>
        <ul>
            <li><strong>Space Efficiency:</strong> The memory an algorithm requires.</li>
            <li><strong>Time Efficiency:</strong> The execution time of an algorithm.</li>
            <li><strong>Importance:</strong> Ensures better performance, especially for large-scale problems.</li>
            <li><strong>Classes of Problems:</strong>
                <ul>
                    <li><strong>P:</strong> Problems solvable in polynomial time.</li>
                    <li><strong>NP:</strong> Problems verifiable in polynomial time.</li>
                    <li><strong>NP-Hard/NP-Complete:</strong> Challenging problems verifiable if a solution exists.</li>
                </ul>
            </li>
            <li><strong>Orders of Growth:</strong> O(1), O(log n), O(n), O(n²), O(2ⁿ).</li>
        </ul>
        </section>
        
        <section>
        <h3>3. Takeaways from Design Principles</h3>
        <ul>
            <li><strong>Divide-and-Conquer:</strong> Breaking problems into subproblems, solving independently, and combining results.</li>
            <li><strong>Greedy Approach:</strong> Making locally optimal choices (e.g., Prim's and Kruskal's algorithms).</li>
            <li><strong>Dynamic Programming:</strong> Solving overlapping subproblems by storing solutions (e.g., Knapsack problem).</li>
        </ul>
        </section>
        
        <section>
        <h3>4. Tree Data Structures</h3>
        <ul>
            <li><strong>Binary Tree:</strong> Simple hierarchical representation.</li>
            <li><strong>BST:</strong> Efficient search, insert, delete operations.</li>
            <li><strong>AVL Tree:</strong> Self-balancing BST for optimized operations.</li>
            <li><strong>Heap:</strong> Used in priority queues and heapsort.</li>
            <li><strong>Trie:</strong> Efficient for string matching and prefix searches.</li>
        </ul>
        </section>
      
        <section>
        <h3>5. Array Query Algorithms</h3>
        <p>Array query algorithms enable efficient data retrieval and updates, optimizing operations for large datasets.</p>
        <ul>
            <li>Applications: Range queries, prefix sums.</li>
            <li>Dynamic range queries: Segment trees and Fenwick trees.</li>
        </ul>
        </section>
        
        <section>
        <h3>6. Trees vs. Graphs</h3>
        <ul>
            <li><strong>Trees:</strong> Acyclic, connected graphs with hierarchical structure. Traversals: Preorder, Inorder, Postorder.</li>
            <li><strong>Graphs:</strong> Network of nodes and edges. Can have cycles. Traversals: Depth First Search (DFS), Breadth First Search (BFS).</li>
            <li><strong>Applications:</strong></li>
            <ul>
                <li>Trees: File systems, hierarchical databases.</li>
                <li>Graphs: Network routing, social connections.</li>
            </ul>
        </ul>
        </section>
        
        <section>
        <h3>7. Sorting and Searching Algorithms</h3>
        <h3>Sorting:</h3>
        <ul>
            <li>Bubble Sort:This algorithm compares adjacent elements and swaps them when necessary. While it's easy to understand, it becomes inefficient with large datasets.</li>
            <li>Quick Sort:It splits the data into smaller sublists, sorts them individually, and then combines them. This approach is quick and effective for handling large datasets.</li>
            <li>Merge Sort: It divides the data into smaller segments, sorts each segment, and then merges them back together, making it an efficient option for large datasets.</li>
            <li>Insertion Sort: This method inserts each element into its correct position in a sorted part of the list, performing well with small or nearly sorted data.</li>
        </ul>
        </section>

        <section>
        <h3>Searching:</h3>
        <ul>
            <li>Linear Search: This algorithm checks each element in sequence, making it simple but slow, especially for larger datasets.
            </li>
            <li>Binary Search: By repeatedly halving the sorted data, this algorithm quickly finds the target element, but it requires the data to be sorted first.</li>
            <li>Hashing: Using a hash function, this technique allows for extremely fast lookups, making it ideal for large datasets.</li>
        </ul>
        </section>

        <section>
        <h3>8. Importance of Graph Algorithms</h3>
        <ul>
            <li><strong>Spanning Trees:</strong> Connect all vertices with minimal weight (e.g., Prim's or Kruskal's).</li>
            <li><strong>Shortest Paths:</strong> Algorithms like Dijkstra's and Bellman-Ford.</li>
            <ul>
                <li>Dijkstra's Algorithm: Dijkstra's algorithm like finding the quickest route to all destinations from a starting
                    point, but only for roads that have non-negative speed limits (no "negative" roads).
                    You start at your starting point, look at all the nearby destinations, and pick the
                    closest one. Then, from there, you look at the next closest destination and keep going.
                    It’s a bit like how a GPS works, constantly recalculating the shortest route as you
                    travel.</li>
                <li>Bellman-Ford Algorithm: Bellman-Ford is like Dijkstra's algorithm but with a superpower: it can handle roads with negative speed limits (or negative weights). However, it’s a bit slower because it needs to check every possible route multiple times to make sure it’s found the shortest path. It’s also capable of detecting situations where a "negative loop" exists, where you could keep going around in a cycle and continuously get closer to the destination.</li>
                <li>Floyd-Warshall Algorithm: Imagine you want to know the shortest path between every pair of places in a town, not just from one starting point. Floyd-Warshall does this by checking all possible pairs of places, and updating the shortest distance between them step by step, kind of like trying every possible route between two cities, one at a time, to make sure you’re taking the fastest option</li>
            </ul>
        </section>

        <section>
        <h3>9. Algorithm Design Techniques</h3>
        <ul>
            <li><strong>Greedy:</strong> Suitable for optimization problems.</li>
            <li><strong>Divide-and-Conquer:</strong> Effective for problems like sorting and matrix multiplication.</li>
            <li><strong>Dynamic Programming:</strong> Best for problems with overlapping subproblems.</li>
            <li><strong>Backtracking:</strong> Useful for exploring multiple possibilities in puzzles.</li>
        </ul>
    </section>
    <!DOCTYPE html>
    <html lang="en">

    <head>

         <div class="button-container">
  <button onclick=<a id="BuscaseNayeem" href="BuscaseNayeem/Business1.html">Business cases</a></button>
</div>
  <style>
  <style>
    
</body>

</html>
